from __future__ import annotations
"""
Documentation Generation Tools for Scout MCP Server.

This module contains:
- scout_generate_docs: Generate documentation from code
- scout_update_docs: Update existing documentation
"""

from pathlib import Path
from typing import Any

from scout.cache import simple_cache
from scout.doc_generation import (
    Audience,
    DocGenerator,
    OutputFormat,
)
from scout.scout_mcp_logging import log_tool_invocation
from scout.tool_output import ToolOutput

# Shared configuration
REPO_ROOT = Path("/Users/vivariumenv1/Vivarium")


@simple_cache(ttl_seconds=300, dependencies=[])
@log_tool_invocation
async def scout_generate_docs(
    request: str,
    audience: str = "developer",
    output_format: str = "markdown",
    target_files: str | None = None,
    technical_depth: str = "medium",
    include_code_examples: bool = True,
    include_api_reference: bool = True,
    ctx: Any = None,
) -> ToolOutput:
    """
    Generate documentation using Scout's AI-powered doc generation.

    This tool uses the same orchestration architecture as the plan tool:
    - Decomposes doc requests into sections
    - Generates sections in parallel for speed
    - Synthesizes into unified documentation

    Args:
        request: What documentation to generate (e.g., "How to use the Scout API")
        audience: Target audience - "user" (non-technical), "developer", or "advanced"
        output_format: Output format - "markdown", "html", "rst", or "plain_text"
        target_files: Optional comma-separated list of specific files to document
        technical_depth: "low", "medium", or "high" technical detail level
        include_code_examples: Include code examples in the documentation
        include_api_reference: Include API reference documentation

    Returns:
        ToolOutput with tool_name="generate_docs", content=generated_docs, cost_usd=actual
    """
    # Parse audience
    audience_enum = Audience.DEVELOPER
    if audience == "user":
        audience_enum = Audience.USER
    elif audience == "advanced":
        audience_enum = Audience.ADVANCED

    # Parse format
    format_enum = OutputFormat.MARKDOWN
    if output_format == "html":
        format_enum = OutputFormat.HTML
    elif output_format == "rst":
        format_enum = OutputFormat.RST
    elif output_format == "plain_text":
        format_enum = OutputFormat.PLAIN_TEXT

    # Parse target files
    files = None
    if target_files:
        files = [f.strip() for f in target_files.split(",")]

    # Create generator
    from scout.doc_generation import (
        AudienceConfig,
        FormatConfig,
    )

    generator = DocGenerator(
        repo_root=REPO_ROOT,
        audience_config=AudienceConfig(
            audience=audience_enum,
            include_code_examples=include_code_examples,
            include_api_reference=include_api_reference,
            technical_depth=technical_depth,
            verbosity="normal",
        ),
        format_config=FormatConfig(
            format=format_enum,
            include_table_of_contents=True,
            include_navigation=False,
            syntax_highlighting=True,
            line_numbers=False,
        ),
        output_path=REPO_ROOT / "docs",
    )

    # Generate documentation
    result = await generator.generate(request, files)

    # Extract actual cost from result
    actual_cost = getattr(result, 'cost', 0.02)

    # Format response
    content = f"""# Generated Documentation

**Request:** {request}
**Audience:** {audience}
**Format:** {output_format}
**Tokens:** {result.tokens}
**Cost:** ${actual_cost:.4f}

---

{result.full_content}

---

*Generated by Scout Doc Gen Tool*
"""

    return ToolOutput.from_content(
        tool_name="generate_docs",
        content=content,
        cost_usd=actual_cost,
        metadata={"request": request, "audience": audience, "output_format": output_format, "tokens": result.tokens},
    )


@simple_cache(ttl_seconds=300, dependencies=[])
@log_tool_invocation
async def scout_update_docs(
    request: str,
    existing_docs: str,
    audience: str = "developer",
    output_format: str = "markdown",
    target_files: str | None = None,
    ctx: Any = None,
) -> ToolOutput:
    """
    Update or extend existing documentation using AI.

    This tool takes existing documentation and extends or updates it
    based on a new request or changes in the codebase.

    Args:
        request: What to update/add in the documentation
        existing_docs: Current documentation content to update
        audience: Target audience - "user", "developer", or "advanced"
        output_format: Output format - "markdown", "html", "rst", or "plain_text"
        target_files: Optional files that may need documentation updates

    Returns:
        ToolOutput with tool_name="update_docs", content=updated_docs, cost_usd=actual
    """
    # For now, generate new docs with context of existing
    # A more sophisticated version would do diff-based updates
    full_request = (
        f"{request}\n\nExisting documentation to consider:\n{existing_docs[:1000]}"
    )

    # Reuse scout_generate_docs implementation
    # It now returns ToolOutput, so we pass it through with modified metadata
    result = await scout_generate_docs(
        request=full_request,
        audience=audience,
        output_format=output_format,
        target_files=target_files,
    )
    # Update tool_name to reflect this is an update operation
    result.tool_name = "update_docs"
    result.metadata["is_update"] = True
    result.metadata["original_request"] = request
    return result
